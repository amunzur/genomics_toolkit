#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import pandas as pd
import matplotlib.pyplot as plt
import cnvlib
import math
import numpy as np
import os
import seaborn as sns
import re
from collections import defaultdict
from cnvlib import core
import argparse

# Define the function to apply the logic for copy status to SNP grid
def get_copy_status_backbone(row):
    if row['chromosome'] in ['chrX', 'chrY']:
        return 'N/A'
    if (row['log2'] < -1 and row['baf'] >= 0.6):
        return 'Deep Deletion'
    elif (row['log2'] > 0.7 and row['baf'] >= 0.6):
        return 'Amplification'
    elif (-1.0 <= row['log2'] <= -0.15 and row['baf'] >= 0.6):
        return 'Shallow Deletion'
    elif (0.15 <= row['log2'] <= 0.7 and row['baf'] >= 0.6):
        return 'Gain'
    elif (-0.15 <= row['log2'] <= 0.15 and row['baf'] >= 0.6):
        return 'CN LOH'
    else:
        return 'Neutral'

def main():    
    parser = argparse.ArgumentParser(description="Generate genome wide copy number plots.")
    parser.add_argument("--cnrdir", required=True, help="Directory containing .fix and .fix.segment files generated by CNVkit.")
    parser.add_argument("--vardir", required=True, help="Directory to VCF variants directory.")
    parser.add_argument("--dir_output", required=True, help="Figure directory.")
    parser.add_argument("--path_SNPs_to_remove", required=False, help="Any SNPs to exclude during plotting.")
    parser.add_argument("--keyword", required=False, help="Only samples with this keyword will be processed. Helpful when you wish to work with a subset of samples in a given directory.")
    args = parser.parse_args()
    
    cnrdir=args.cnrdir
    vardir=args.vardir
    dir_output=args.dir_output
    path_SNPs_to_remove=args.path_SNPs_to_remove
    keyword=args.keyword
    
    cnr_paths=[os.path.join(cnrdir, f) for f in os.listdir(cnrdir)]
    var_paths=[os.path.join(vardir, f) for f in os.listdir(vardir)]
    
    samples=[f.replace("segment.cnn.fix", "") for f in os.listdir(cnrdir)]
    
    #IMPORT A LIST OF SNPS TO EXCLUDE DUE TO RECURRENT DEVIATION FROM 50% IN WBC DATA
    if path_SNPs_to_remove is not None:
        with open(path_SNPs_to_remove, 'r') as f:
            lines = f.readlines()
            values_to_remove = [(line.split()[0], int(line.split()[1])) for line in lines]
    
        values_set = set(values_to_remove)
    
    
    ##########################
    #### Begin Processing ####
    ##########################
    if keyword is not None:
        samples = [f.replace(".cnn.fix", "") for f in os.listdir(cnrdir) if f.endswith(".cnn.fix") and keyword in f]
    else:
        samples = [f.replace(".cnn.fix", "") for f in os.listdir(cnrdir) if f.endswith(".cnn.fix")]
    
    for sample in samples:
        
        #####################################################
        ######### Load and format the SNP Grid data #########
        #####################################################
        
        path_cnr=os.path.join(cnrdir, sample+".cnn.fix")
        path_var=os.path.join(vardir, sample+".vcf")
        
            
        cnr=cnvlib.read(path_cnr).drop_low_coverage()
        try:
            var = cnvlib.cmdutil.load_het_snps(path_var, sample_id=None, normal_id=None, min_variant_depth=20)
        # Continue processing var...
        except ValueError as e:
            print(f"Skipping {path_var}: {e}")
            continue
        
        #######VCF FILE FILTERING######
        
        #REMOVE HOMOZYGOTES
        variant_df=var.data
        variant_df=variant_df.loc[variant_df['alt_freq'] < 0.9]
        
        # Remove excluded SNPs
        if path_SNPs_to_remove is not None:
            snp_mask = variant_df.apply(lambda row: (row['chromosome'], row['start']) not in values_set, axis=1)
            variant_df = variant_df[snp_mask]
        
        #REMOVE INDELS
        remove_indel_df = variant_df[(variant_df['ref'].str.len() <= 1) & (variant_df['alt'].str.len() <= 1)]
        
        #REFORMAT ALLELE FREQUENCY
        remove_indel_df['alt_freq']=abs(0.5 - remove_indel_df['alt_freq'])+0.5
        
        #DO NOT ALLOW VARIANTS TO BE EXACTLY 0.5 ELSE CNVLIB PLOTS TWO LINES
        remove_indel_df['alt_freq'] = remove_indel_df['alt_freq'].apply(lambda x: x + 0.001 if x == 0.5 else x)
        
        #REMOVE SNPs WHERE VAF IS MORE THAN 10% OFF FROM AVERAGE OF ADJACENT SNPs
        var_rolling_avg = remove_indel_df['alt_freq'].rolling(window=3, center=True).mean()
        var_outlier_mask = abs(remove_indel_df['alt_freq'] - var_rolling_avg) > 0.10
        
        #APPLY BACK TO VAR OBJECT
        remove_indel_df = remove_indel_df[~var_outlier_mask]
        var.data = remove_indel_df
        
        #######LOAD SEGMENTATION######
        
        path_cns_segmentation=path_cnr+".segment"
        cns_df=cnvlib.read(path_cns_segmentation).data
        
        #####
        ###Fix assignment of BAF to each segment here
        #####
        
        # Iterate over each row in cns_df
        for index, cns_row in cns_df.iterrows():
            # Extract the chromosome and start/end positions
            chromosome = cns_row[0]
            start = cns_row[1]
            end = cns_row[2]
            
            # Filter remove_indel_df for rows that overlap with the current segment
            overlapping_rows = remove_indel_df[
                (remove_indel_df['chromosome'] == chromosome) &
                (remove_indel_df['start'] <= end) &
                (remove_indel_df['end'] >= start)
            ]
            
            # Calculate the median alt_freq if there are overlapping rows
            if not overlapping_rows.empty:
                median_alt_freq = overlapping_rows['alt_freq'].median()
            else:
                median_alt_freq = None  # or use np.nan for a numeric representation
            
            # Assign the median_alt_freq to the corresponding row in cns_df
            cns_df.at[index, 'baf'] = median_alt_freq
            
            # cns.data=cns_df
            
            #Assign copy status
            cns_df['copy_status'] = cns_df.apply(get_copy_status_backbone, axis=1)
            
            cns_df.to_csv("/groups/wyattgrp/users/amunzur/COMPOST_BIN/temp.cns", sep="\t", index=False)
            cns = cnvlib.read("/groups/wyattgrp/users/amunzur/COMPOST_BIN/temp.cns")
                    
            #######COPY NUMBER RATIO FILTERING######
            
            #REMOVE PROBES WHERE LOG2 IS MORE THAN 0.3 OFF FROM AVERAGE OF ADJACENT PROBES
            filter_cnr_df=cnr.data
            cnr_rolling_avg = filter_cnr_df['log2'].rolling(window=3, center=True).mean()
            cnr_outlier_mask = abs(filter_cnr_df['log2'] - cnr_rolling_avg) > 0.3
            
            #APPLY BACK TO CNR OBJECT
            filter_cnr_df = filter_cnr_df[~cnr_outlier_mask]
            cnr.data=filter_cnr_df
        
        #Plot SNP Grid scatter first using the cnvlib library from CNVKit
        fig = cnvlib.do_scatter(cnr, segments=cns, segment_color='black', variants=var)
        # fig = cnvlib.do_scatter(cnr, segment_color='black', variants=var)
        fig.set_size_inches(24, 8)
        axes = fig.get_axes() #Extract ax1 (log ratio) and ax2 (BAF) produced by cnvlib.do_scatter
        ax1 = axes[0]
        ax2 = axes[1]
        
        #Color and Coordinate the SNP GRid    
        #set alpha of points    
        for scatter in ax1.collections:
            scatter.set_alpha(0.4)
            
        for scatter in ax2.collections:
            scatter.set_alpha(0.4)
        
        #Color the chromosomes
        # colors = ['#435098', '#86b289', '#8b3730', '#853ea9', '#c4a75c', '#435098', '#86b289', '#8b3730', '#853ea9',
        #           '#c4a75c', '#435098', '#86b289', '#8b3730', '#853ea9', '#c4a75c', '#435098', '#86b289', '#8b3730',
        #           '#853ea9', '#c4a75c', '#435098', '#86b289', '#8b3730', '#853ea9']
        # for i, collection in enumerate(ax1.collections):
        #    collection.set_color(colors[i])
           
        # for i, collection in enumerate(ax2.collections):
        #    collection.set_color(colors[i])
          
        #No attribute for SNP segment line color. Make them black and bring forward here.
        for line in ax2.get_lines():
            x_data = line.get_xdata()
            y_data = line.get_ydata()
            
            line.set_color('black')
            line.set_zorder(10) 
        
        #Set Plot Ylims
        log2_segvals=cns["log2"]
        
        seg_max=log2_segvals.max()
        rounded_max_value = math.ceil(seg_max * 2) / 2
        
        if rounded_max_value > 1.5:
            y_lim_high=rounded_max_value
        else:
            y_lim_high=1.5
        
        ax1.set_ylim(-1.5, y_lim_high)
        
        # Add gridlines
        for y in np.arange(-2, y_lim_high, 0.5):
            ax1.axhline(y = y, color = 'k', linestyle = 'dotted', linewidth=0.75, alpha=0.3)
            
        for y in np.arange(0.5, 1.0, 0.1):
            ax2.axhline(y = y, color = 'k', linestyle = 'dotted', linewidth=0.75, alpha=0.3)
        
        #customize plot   
        ax1.set_ylabel("Log Ratio", fontsize=14)
        ax1.tick_params(axis='both', labelsize=12)
        
        basename = os.path.basename(path_cnr)
        clean_name = re.sub(r'.cnn.*$', '', basename)
        title=f"{clean_name}\nVariants file: {path_var}\nCNV file: {path_cnr}"
        ax1.set_title(title, pad=16, fontsize=18)
        
        ax2.set_ylabel("BAF", fontsize=14, labelpad=16)
        ax2.tick_params(axis='both', labelsize=12)
        ax2.set_ylim(0.5, 1.0)
            
        os.makedirs(dir_output, exist_ok=True)
        fig.savefig(os.path.join(dir_output, clean_name+".png"), dpi=300, bbox_inches='tight')
        plt.close(fig)


if __name__ == "__main__":
    main()

# Example
# python plot_all_chip_cnv.py \
#     --cnrdir /path/to/fix_snp
#     --vardir /path/to/variants
#     --plot_output_dir /path/figures
#     --path_SNPs_to_remove /path/to/snps.txt